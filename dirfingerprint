#!/usr/bin/env python3
_V='20200524' #-b, and fixed a bug brought by '-d'
#_V='20191011' #-d
#_V='20190424' #fix a bug with gluster, and compatible with python3.4
#_V='20190411' #Add SubdirCount, and Fingerprint calculation v1 -> v2
#_V='20190410' #print non-utf-8 character
#_V='20190409' #refactor on-the-fly
#_V='20190204' #print stats on-the-fly
#_V='20190119' #default current folder
#_V='20190108' #support multiple directories now
#_V='20190107' #initial github release
import sys, argparse, subprocess, os.path, datetime, pickle, threading, hashlib
def version():
	print(_V)
	sys.exit(0)
def get_args():
	parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
		description='''
It is always a pain in the eyes to compare two huge directories. Command 'du' doesn't work in all cases because it counts the size of each regular file, directory, soft-link, pipe, block device, etc, For example, if a directory has only empty files, 'du' reports a non-zero size for the directory, and the size varies depending on the underlying filesystem type. Most ordinary users actually don't care about those special files' size.

To rub salt in a wound, how can we find the folders that are renamed or moved to another location?

Further, almost all distributed filesystems don't have a good performance to access their metadata. Repeating some commands such as 'rsync -nav' on them isn't efficient.

Thus, here is 'dirfingerprint', it reports 6 properties for each subdirectories. The properties are calculated on the subdirectory recursively.
FileBytes:\ttotal size of the regular files. This number should be smaller than 'du -b' as dirfingerprint doesn't count directory's size
FileBlocks:\ttotal blocks of the regular files.
FileCount:\tcount of the regular files
FileMinMtime:\tthe oldest mtime of the regular files
FileMaxMtime:\tthe newest mtime of the regular files
SubdirCount:\tcount of all subdirectories
SpecialCount:\tcount of all special files that are not regular file or directory
FingerPrint:\ta md5sum based on three parts. The first part is the two numbers of SubdirCount and SpecialCount, the second part is a list of name, size and mtime of the regular files that are one level under the directory, and the third part is a list of name and FingerPrint of all the subdirectories that are one level under the directory.
Dir:\tname of the subdirectory

Here is an example of how FingerPrint is calculated, run these commands
$ mkdir test
$ touch -t "201901010101" test/f1
$ touch -t "201901010101" test/f2
$ mkdir test/subdir1
$ mkdir test/subdir1/subdir2
$ dirfingerprint test
#FingerPrint calculation of the empty directory 'test/subdir1/subdir2'
$ echo "0 0" | md5sum
#FingerPrint calculation of the directory 'test/subdir1'
$ echo -e "1 0\\nsubdir2 5928dd99059f0c73963285d86f359fdb" | md5sum
#FingerPrint calculation of the directory 'test'
$ stat -c %Y test/f1 test/f2 #get the mtime
$ echo -e "1 0\\nf1 0 1546322460\\nf2 0 1546322460\\nsubdir1 eecee4276b062aa6c1717dde01094d1d" | md5sum

An experimental feature is GlusterFS support, it can access GlusterFS brick nodes and get the metadata directly without network delay. an example is
$ dirfingerprint --gluster-brick=node1:/brick --gluster-brick=node2:/brick .
''')
	parser.add_argument("DIR", help="directory", nargs='*')
	parser.add_argument("-x", "--one-file-system", action="store_true", help="skip directories on different file systems")
	parser.add_argument("-d", "--max-depth", type=int, default=-1, help="print subdirectories at most DEPTH, negative integer prints every subdirectory")
	parser.add_argument("-b", "--blocks", action="store_true", help="calculate st_blocks instead of st_size")
	parser.add_argument("--gluster-brick", help="HOSTNAME:PREFIX", action='append')
	parser.add_argument("--version", action="store_true", help="output version information and exit")
	return parser.parse_args()

class DirObj:
	def __init__(self, cwd, printdir, prefix, level, args):
		self.files = []
		self.dirs = {}
		self.special_count = 0
		try:
			for ld in sorted(os.listdir(prefix + cwd)):
				if args.gluster_brick == ['true'] and ld == '.glusterfs': continue
				fullpath = prefix + cwd + '/' + ld
				if os.path.islink(fullpath):
					self.special_count += 1
				elif os.path.isfile(fullpath):
					ls = os.lstat(fullpath)
					if args.gluster_brick == ['true'] and ls.st_size == 0 and ls.st_mode == 33280: continue
					file_size = ls.st_blocks if args.blocks else ls.st_size
					self.files.append([ld, file_size, int(ls.st_mtime)])
				elif os.path.isdir(fullpath):
					if os.path.ismount(fullpath) and args.one_file_system: continue
					self.dirs[ld] = DirObj(cwd + '/' + ld, printdir + '/' + ld, prefix, level+1, args)
				else:
					self.special_count += 1
		except PermissionError as e:
			print(e, file=sys.stderr)
		if args.gluster_brick != ['true']: self.finger_print(printdir, level, args)
	def _to_iso_if_not_utf8(sin):
		try:
			return sin.encode('utf-8', 'surrogateescape').decode('utf-8')
		except UnicodeDecodeError:
			return sin.encode('utf-8', 'surrogateescape').decode('iso-8859-1')
	def finger_print(self, path, level, args):
		self.total_bytes = sum([f[1] for f in self.files])
		self.total_count = len(self.files)
		self.subdir_count = len(self.dirs)
		if self.total_count > 0:
			f_times = [f[2] for f in self.files]
			self.min_time = min(f_times)
			self.max_time = max(f_times)
		else:
			self.min_time = sys.maxsize
			self.max_time = 0
		md5 = hashlib.md5()
#		md5.update(f'{self.subdir_count} {self.special_count}\n'.encode())
		md5.update(('%d %d\n' % (self.subdir_count, self.special_count)).encode())
		for fname, fsize, ftime in sorted(self.files):
			md5.update(('%s %d %d\n' % (fname, fsize, ftime)).encode('utf-8', 'surrogateescape'))
		for child_cwd, child_dir in sorted(self.dirs.items()):
			if args.gluster_brick == ['true']: child_dir.finger_print(path + '/' + child_cwd, level+1, args)
			self.total_bytes += child_dir.total_bytes
			self.total_count += child_dir.total_count
			self.subdir_count += child_dir.subdir_count
			if self.min_time > child_dir.min_time: self.min_time = child_dir.min_time
			if self.max_time < child_dir.max_time: self.max_time = child_dir.max_time
			self.special_count += child_dir.special_count
			md5.update(('%s %s\n' % (child_cwd, child_dir.md5sum)).encode('utf-8', 'surrogateescape'))
		self.md5sum = md5.hexdigest()
		if self.total_count == 0:
			s_min_time = 'NA'
			s_max_time = 'NA'
		else:
			s_min_time = datetime.datetime.fromtimestamp(self.min_time)
			s_max_time = datetime.datetime.fromtimestamp(self.max_time)
		if level <= args.max_depth or args.max_depth < 0:
			print(self.md5sum, self.total_bytes, self.total_count, s_min_time, s_max_time, self.subdir_count, self.special_count, DirObj._to_iso_if_not_utf8(path), sep='\t')
		self.dirs.clear()
	def add_dir(self, ano):
		self.files += ano.files
		self.special_count += ano.special_count
		for ano_cwd, ano_child in ano.dirs.items():
			self_child = self.dirs.get(ano_cwd)
			if self_child is None:
				self.dirs[ano_cwd] = ano_child
			else:
				self_child.add_dir(ano_child)

def ssh(brick_dirs, idx, args, realexe, brick_name, realdir):
	cmd = realexe
	if args.one_file_system: cmd += ' -x'
	cmd += ' --gluster-brick=true ' + realdir
	brick_dirs[idx] = pickle.loads(subprocess.check_output(['ssh', brick_name, cmd]))

def do_one_dir(args, onedir):
	realdir = os.path.realpath(onedir)
	if not os.path.isdir(realdir):
		raise Exception('ERR-001: %s is not a directory' % realdir)
	if args.gluster_brick is not None and args.blocks:
		raise Exception('ERR-002: --blocks cannot be used with --gluster-bricks')
	if args.gluster_brick is not None and args.gluster_brick != ['true']:
		brick_names, prefixes = [], []
		for s in args.gluster_brick:
			sp = s.split(':')
			brick_names.append(sp[0])
			prefixes.append(sp[1])
		threads = []
		realexe = os.path.realpath(sys.argv[0])
		brick_dirs = [0 for i in range(len(brick_names))]
		for idx in range(len(brick_names)):
			t = threading.Thread(target=ssh, args=(brick_dirs, idx, args, realexe, brick_names[idx], prefixes[idx] + realdir))
			t.start()
			threads.append(t)
		for idx in range(len(brick_names)):
			threads[idx].join()
			if idx == 0:
				root = brick_dirs[idx]
			else:
				root.add_dir(brick_dirs[idx])
		args.gluster_brick = ['true']
		root.finger_print(onedir, 0, args)
	else:
		root = DirObj('', onedir, realdir, 0, args)
		if args.gluster_brick == ['true']: sys.stdout.buffer.write(pickle.dumps(root))

def main():
	args = get_args()
	if args.version: version()
	if args.blocks:
		print('FingerPrint(v2)\tFileBlocks\tFileCount\tFileMinMtime\tFileMaxMtime\tSubdirCount\tSpecialCount\tDir')
	else:
		print('FingerPrint(v2)\tFileBytes\tFileCount\tFileMinMtime\tFileMaxMtime\tSubdirCount\tSpecialCount\tDir')
	if args.DIR == []: args.DIR = '.'
	for onedir in args.DIR:
		while len(onedir) > 1 and onedir[-1] == '/': onedir = onedir[:-1]
		do_one_dir(args, onedir)

if __name__ == '__main__': main()
